package {namespace};

import java.math.BigDecimal;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.Callable;

import com.eclipsesource.v8.V8Value;
import com.eclipsesource.v8.V8Array;
import com.eclipsesource.v8.V8Object;
import com.eclipsesource.v8.JavaCallback;
import com.eclipsesource.v8.JavaVoidCallback;
import com.paypal.manticore.IManticoreTypeConverter;

/**
 * {@lineify indent=1}{description|s}{/lineify}
 *
 * DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED AND SHOULD NOT BE CHECKED IN.
 * {@sourceDocument/}
 * {?copyright}
 * {copyright}
{/copyright} 
 */
{^protected}public {/protected}class {packedName} extends {?inherits}{inherits}{:else}{baseClass}{/inherits} {
  //<editor-fold description="Constructors">
  /**
   * Internal constructor from a V8 value. Make sure you copy it if it will be released automatically (i.e. if you didn't make it)
   */
  {packedName}(V8Object jsValue) {
    super(jsValue);
  }

  /**
   * Internal static that allows more specific types to be created by analyzing JS property
   */
  static {packedName} nativeInstanceForObject(V8Object jsValue) {
    if (jsValue == null || jsValue.isUndefined()) {
      return null;
    }
{?subclasses}    Object nativeClass = jsValue.get("_native");
    if (nativeClass == null || !(nativeClass instanceof String))
    {
      return new {packedName}(jsValue);
    }
{#subclasses}    if ("{name}".equals(nativeClass))
    {
      return new {name}(jsValue);
    }
{/subclasses}{/subclasses}
    return new {packedName}(jsValue);
  }
{#instanceConstructor}{^private}
  /**
   * {@lineify indent=3}{description|s}{/lineify}
   */
  public {packedName}({#args}final {@type}{type}{/type} {name}{@sep}, {/sep}{/args}) {
    super();
    getEngine().getExecutor().run(new Runnable() {
      @Override public void run() {
        V8Array args = getEngine().createJsArray()
            {#args}.push({>toJs target="{type}" arg="{name}"/}){@sep}
            {/sep}{/args};
        {packedName}.this.impl = getEngine().createJsObject("{name}", args);
      }
    });
  }
  {/private}{:else}
  public {packedName}() {
    super();
    getEngine().getExecutor().run(new Runnable() {
        @Override public void run() {
            {packedName}.this.impl = getEngine().createJsObject("{name}", null);
        }
    });
  }{/instanceConstructor}
  //</editor-fold>
{?fields}
  //<editor-fold description="Property getters and setters">
{/fields}{#fields}{>field/}{/fields}{?fields}
  //</editor-fold>
{/fields}
{?callbacks}  //<editor-fold description="Interface declarations for callbacks">
{/callbacks}{#callbacks}{>ifaceDecl suffix="Callback"/}{/callbacks}{?callbacks}
  //</editor-fold>
{/callbacks}
{?events}  //<editor-fold description="Interface declarations for events">
{/events}{#events}{>ifaceDecl suffix="Observer"/}{/events}{?events}
  //</editor-fold>
{/events}
{?staticMethods}
  //<editor-fold description="Static Methods">
{/staticMethods}{#staticMethods}{>method static="true"/}{/staticMethods}{?staticMethods}
  //</editor-fold>
{/staticMethods}
{?methods}
  //<editor-fold description="Methods">
{/methods}
{#methods}{>method/}{/methods}
{^hasToString}{>toString/}
  //</editor-fold>
{/hasToString}
{?hasToString}{?methods}
  //</editor-fold>
{/methods}{/hasToString}
{?events}
  //<editor-fold description="Event subscribe/unsubscribe">
{/events}{#events}{>event/}{/events}{?events}
  //</editor-fold>
{/events}
{?callbacks}
  //<editor-fold description="Internal callback wrappers" defaultstate="collapsed">
{/callbacks}{#callbacks}{>wrapDecl suffix="Callback"/}{/callbacks}{?callbacks}
  //</editor-fold>{/callbacks}
{?events}
  //<editor-fold description="Internal event wrappers" defaultstate="collapsed">
{/events}{#events}
  private Map<{@firstCap}{name}{/firstCap}Observer,V8Object> {name}Handlers;

  {>wrapDecl suffix="Observer"/}{/events}{?events}
  //</editor-fold>
{/events}
}
