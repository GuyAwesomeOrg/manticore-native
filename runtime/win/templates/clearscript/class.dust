using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Manticore;

/**
 * {packedName}.cs
 * {@lineify indent=1}{description|s}{/lineify}
 *
 * DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED AND SHOULD NOT BE CHECKED IN.
 * {@sourceDocument/}
{^copyright} *
 * {copyright}
{/copyright} */
namespace {namespace}
{
  public class {packedName} : {?inherits}{inherits}{:else}{baseClass}{/inherits} {
{#callbacks}
    /**
     * {@lineify indent=9}{description|s}{/lineify}
     */
    public delegate {^returns}void{:else}{@type}{returns.type}{/type}{/returns} {@firstCap}{name}{/firstCap}Delegate({>argList/});
{/callbacks}{#events}
    /**
     * {@lineify indent=5}{description|s}{/lineify}
     */
    public delegate {^returns}void{:else}{@type}{returns.type}{/type}{/returns} {@firstCap}{name}{/firstCap}Delegate({packedName} sender{?args}, {/args}{>argList/});
    private System.Collections.Generic.Dictionary<{@firstCap}{name}{/firstCap}Delegate,object> {name}Handlers;
{/events}
      {?inherits}new {/inherits}internal static {packedName} NativeInstanceForObject(dynamic value) {
      if (Engine.IsNullOrUndefined(value)) {
        return null;
      }
      {?subclasses}var nativeClass = value["_native"];
      if (Engine.IsNullOrUndefined(nativeClass)) {
        return new {packedName}(new JsValueHolder(value));
      }
      var strNativeClass = nativeClass.ToString();
      {#subclasses}
      if ("{name}".Equals(strNativeClass)) {
        return new {name}(new JsValueHolder(value));
      }{/subclasses}{/subclasses}
      return new {packedName}(new JsValueHolder(value));
    }

    internal {packedName}(object value) : base(value) {
    }
{#instanceConstructor}{^private}
    /**
     * {@lineify indent=9}{description|s}{/lineify}
     */
    public {packedName}({>argList/}) {
      {?args}dynamic args = Engine.ManticoreJsObject._.array();
      {/args}{#args}args.push({>toJs target="{type}" arg="{name}"/});
{/args}
      this.impl = Engine.CreateJsObject("{name}", {?args}args{:else}null{/args});
    }
{/private}
    {?args}/**
     * Make subclasses work with classes with non-default constructors
     */
    protected {packedName}() {}{/args}
{:else}
    public {packedName}() {
      this.impl = Engine.CreateJsObject("{name}", null);
    }
{/instanceConstructor}
{#methods}{>method/}{/methods}
{#staticMethods className=name}{>method isStatic="true"/}{/staticMethods}
{#fields}
        /**
         * {@lineify indent=9}{description|s}{/lineify}
         */
        public {@type}{type}{/type} {@firstCap}{name}{/firstCap} {
            get {
                return Engine.JsWithReturn(() => {>toNative target="{type}" arg="this.impl.{name}"/});
            }
    {^readonly}
            set {
                Engine.Js(() => {
                    var impl = {>toJs target="{type}" arg="value"/};
                    this.impl.{name} = impl;
                });
           }
    {/readonly}
        }
{/fields}
{#callbacks}
        private {>delegateDecl/} WrapDelegate({@firstCap}{name}{/firstCap}Delegate _delegate) {
            return new {>delegateDecl/}(({#args}{name}{@sep}, {/sep}{/args}) => {
                {?returns}var returnValue = {/returns}_delegate({#args}{>toNative target="{type}" arg="{name}"/}{@sep}, {/sep}{/args});
                {?returns}return {>toNative target="{returns.type}" arg="returnValue"/};{/returns}
            });
        }
{/callbacks}{#events}
        public event {@firstCap}{name}{/firstCap}Delegate {@firstCap}{name}{/firstCap}
        {
            add
            {
                var _wrapped = Engine.ManticoreJsObject._.fn(WrapDelegate(value), {args.length}+1);
                if ({name}Handlers == null) {
                    {name}Handlers = new System.Collections.Generic.Dictionary<{@firstCap}{name}{/firstCap}Delegate,object>();
                }
                this.impl.on("{name}",_wrapped);
                {name}Handlers[value] = _wrapped;
            }
            remove
            {
                if ({name}Handlers != null) {
                    var _wrapped = {name}Handlers[value];
                    if (_wrapped != null) {
                        this.impl.removeListener("{name}",_wrapped);
                        {name}Handlers.Remove(value);
                    }
                }
            }
        }

        private {>delegateDecl/} WrapDelegate({@firstCap}{name}{/firstCap}Delegate _delegate) {
            return new {>delegateDecl/}(({#args}{name}{@sep}, {/sep}{/args}) => {
                {?returns}var returnValue = {/returns}_delegate(this{?args}, {/args}{#args}{>toNative target="{type}" arg="{name}"/}{@sep}, {/sep}{/args});
                {?returns}return {>toNative target="{returns.type}" arg="returnValue"/};{/returns}
            });
        }
{/events}
    }
}
